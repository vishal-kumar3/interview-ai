// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  username      String?   @unique
  name          String?
  password      String?
  image         String?
  role          UserRole  @default(USER)

  accounts          Account[]
  resumes           Resume[]
  jobDescriptions   JobDescription[]
  interviewSessions InterviewSession[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UserRole {
  USER
  ADMIN
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model Resume {
  id                String             @id @default(uuid())
  userId            String
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  fileName          String
  fileUrl           String?
  parsedData        Json
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  interviewSessions InterviewSession[]
}

model JobDescription {
  id                String             @id @default(uuid())
  userId            String
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  title             String
  company           String?
  parsedData        Json
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  interviewSessions InterviewSession[]
}

enum InterviewType {
  TECHNICAL
  BEHAVIORAL
  SITUATIONAL
}

enum Difficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum InterviewStatus {
  STARTED
  COMPLETED
  ABANDONED
}

model InterviewSession {
  id                String             @id @default(uuid())
  title             String
  userId            String
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  resumeId          String?
  resume            Resume?            @relation(fields: [resumeId], references: [id])
  jobDescriptionId  String?
  jobDescription    JobDescription?    @relation(fields: [jobDescriptionId], references: [id])
  interviewType     InterviewType      @default(TECHNICAL)
  difficulty        Difficulty
  additionalNotes   String?
  status            InterviewStatus    @default(STARTED)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  questions         Question[]
  responses         Response[]
  sessionMetadata   SessionMetadata?
  interviewFeedback InterviewFeedback?
}

model SessionMetadata {
  id               String           @id @default(uuid())
  sessionId        String           @unique
  session          InterviewSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  aiInstructions   String
  aiPromptContext  Json[] // Store the AI context for consistency
  focusAreas       String[] // Areas to focus on during interview
  avoidTopics      String[] // Topics to avoid
  customSettings   Json? // Custom interview settings
  conversationFlow Json? // Tracks: question sequences, topic transitions, follow-up patterns, interview phases
  // Example conversationFlow structure:
  // {
  //   "currentPhase": "technical_deep_dive",
  //   "questionSequence": ["q1_id", "q2_id", "q3_followup_id"],
  //   "topicTransitions": [
  //     {"from": "react_basics", "to": "state_management", "reason": "good_understanding"},
  //     {"from": "state_management", "to": "performance", "reason": "follow_up_needed"}
  //   ],
  //   "followUpTriggers": {
  //     "q2_id": ["incomplete_answer", "mentioned_hooks"],
  //     "q3_followup_id": ["needs_clarification"]
  //   },
  //   "interviewPath": "adaptive" // or "structured"
  // }
}

model Question {
  id                 String           @id @default(uuid())
  sessionId          String
  session            InterviewSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  text               String
  type               InterviewType
  parentId           String? // For follow-up questions
  parent             Question?        @relation("QuestionFollowUp", fields: [parentId], references: [id], onDelete: Cascade)
  followUps          Question[]       @relation("QuestionFollowUp")
  isFollowUp         Boolean          @default(false)
  followUpDepth      Int              @default(0) // Track how deep the follow-up chain is
  difficulty         Difficulty? // Question-specific difficulty
  topic              String? // e.g., "React", "System Design", "Leadership"
  aiContext          Json? // Store AI context that led to this question
  evaluationCriteria String[]
  followUpTriggers   Json?
  createdAt          DateTime         @default(now())
  response           Response?
}

model Response {
  id           String           @id @default(uuid())
  questionId   String           @unique
  question     Question         @relation(fields: [questionId], references: [id], onDelete: Cascade)
  sessionId    String
  session      InterviewSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  responseType String // "text", "audio", "video"
  content      String?
  fileUrl      String?
  duration     Int? // response time in seconds
  confidence   Float? // AI-assessed confidence level
  keyPoints    Json? // extracted key points from response
  createdAt    DateTime         @default(now())
  feedback     Feedback?
}

model Feedback {
  id         String   @id @default(uuid())
  responseId String   @unique
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)
  content    String
  score      Int?
  createdAt  DateTime @default(now())
}

enum HireRecommendation {
  STRONGLY_RECOMMEND
  RECOMMEND
  NEUTRAL
  DO_NOT_RECOMMEND
}

model InterviewFeedback {
  id                 String             @id @default(uuid())
  sessionId          String             @unique
  session            InterviewSession   @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  overallScore       Int?
  feedback           String
  hireRecommendation HireRecommendation
  strengths          String[]
  weaknesses         String[]
  improvementAreas   String[]
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
}
